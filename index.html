<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>P2P File Transfer — Full (Transcode)</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap">
<style>
:root{
  --bg:#0b1220; --card:#071022; --text:#e6eef6; --muted:#9aa9b8; --accent:#06b6d4; --glass:rgba(255,255,255,0.03);
}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:var(--text);}
.app{max-width:1100px;margin:18px auto;padding:18px}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px}
h1{margin:0;font-size:20px}
.small{font-size:13px;color:var(--muted)}
.card{background:var(--card);padding:14px;border-radius:12px;margin-top:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
.row{display:flex;gap:12px;flex-wrap:wrap}
.col{flex:1;min-width:260px}
.input{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
.btn{background:linear-gradient(90deg,var(--accent),#7c3aed);border:none;color:#021018;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}
.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px;border-radius:8px}
.video{width:100%;border-radius:8px;background:#000}
.progress{height:12px;background:var(--glass);border-radius:999px;overflow:hidden}
.progress > i{display:block;height:100%;background:linear-gradient(90deg,#34d399,#06b6d4);width:0%}
.fileRow{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);margin-bottom:8px}
.qr{width:110px;height:110px;border-radius:8px;background:#071428;display:flex;align-items:center;justify-content:center}
.toast{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#071026;padding:8px 12px;border-radius:8px;color:#fff;box-shadow:0 6px 30px rgba(2,6,23,0.5)}
.light{--bg:#f7fafc;--card:#fff;--text:#0b1220;--muted:#475569;--accent:#0ea5a4}
@media(max-width:820px){ .row{flex-direction:column} .header{flex-direction:column;align-items:flex-start} }
</style>
</head>
<body class="dark">
<div class="app">
  <div class="header">
    <div>
      <h1>P2P File Transfer — Transcode Enabled</h1>
      <div class="small">Client-side transcoding reduces sender upload. Passworded rooms, QR, progress, mute, exit, dark mode.</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <label class="small" style="margin-right:8px">Theme</label>
      <button id="themeToggle" class="ghost">Toggle</button>
    </div>
  </div>

  <!-- ROOM -->
  <div class="card">
    <div class="row">
      <div class="col">
        <label class="small">Room ID</label>
        <input id="roomId" class="input" placeholder="room-id (must match on both devices)">
      </div>
      <div style="width:220px">
        <label class="small">Room Password</label>
        <input id="roomPassword" class="input" placeholder="required">
      </div>
      <div style="width:200px;display:flex;flex-direction:column;gap:8px">
        <button id="createBtn" class="btn">Create Room</button>
        <button id="joinBtn" class="btn">Join Room</button>
      </div>
      <div style="width:140px;text-align:center">
        <label class="small">Share</label>
        <div id="qrWrap" class="qr" title="QR code link">QR</div>
        <div style="margin-top:8px"><a id="shareLink" class="small" href="#" target="_blank">—</a></div>
      </div>
    </div>
    <div style="margin-top:10px">
      <div id="roomMsg" class="small"></div>
    </div>
  </div>

  <!-- Video & file UI -->
  <div class="card row" style="align-items:flex-start">
    <div class="col">
      <div style="display:flex;gap:8px;align-items:center">
        <button id="muteAudio" class="ghost">Mute Audio</button>
        <button id="muteVideo" class="ghost">Mute Video</button>
        <button id="exitBtn" class="ghost">Exit Room</button>
      </div>
      <div style="margin-top:10px">
        <label class="small">Local Video</label>
        <video id="localVideo" class="video" autoplay playsinline muted></video>
      </div>
      <div style="margin-top:10px">
        <label class="small">Remote Video</label>
        <video id="remoteVideo" class="video" autoplay playsinline></video>
      </div>
    </div>

    <div class="col">
      <div style="display:flex;gap:8px;align-items:center">
        <label class="small">Select files (multiple)</label>
        <input id="fileInput" type="file" multiple style="margin-left:auto">
      </div>

      <div id="fileList" class="list" style="margin-top:10px"></div>

      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="sendQueueBtn" class="btn">Send Queue</button>
        <button id="clearQueueBtn" class="ghost">Clear Queue</button>
      </div>

      <div style="margin-top:12px">
        <div class="small">Transcode Options</div>
        <label class="small">Target bitrate (kbps)</label>
        <input id="bitrateInput" type="number" class="input" value="1200" min="200" max="5000" />
        <div class="small" style="margin-top:6px">Lower bitrate → smaller upload but lower quality. Resolution preserved.</div>
      </div>

      <div style="margin-top:12px">
        <div class="small">Send Progress</div>
        <div class="progress" style="margin-top:8px"><i id="sendBar" style="width:0%"></i></div>
        <div class="small" id="sendStats"></div>
      </div>

      <div style="margin-top:12px">
        <div class="small">Receive Progress</div>
        <div class="progress" style="margin-top:8px"><i id="recvBar" style="width:0%"></i></div>
        <div class="small" id="recvStats"></div>
        <div id="receiveFiles" style="margin-top:8px"></div>
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:12px">
    <div class="small">Logs & status</div>
    <pre id="log" style="height:200px;overflow:auto;background:transparent;border:none;padding:6px"></pre>
  </div>
</div>

<div id="toast" class="toast" style="display:none"></div>

<!-- Module script: Firebase v10 + app logic -->
<script type="module">
/* ------------------------------
   Full single-file app
   - Firestore v10 (modular)
   - Passworded rooms
   - ffmpeg.wasm on-demand transcoding
   ------------------------------ */

// ----- Your Firebase config (kept from you) -----
const firebaseConfig = {
  apiKey: "AIzaSyB0Ex5-_mLf8KNENaK0ugRk7ow1fORUq2k",
  authDomain: "sending-file-90a27.firebaseapp.com",
  projectId: "sending-file-90a27",
  storageBucket: "sending-file-90a27.firebasestorage.app",
  messagingSenderId: "319899445088",
  appId: "1:319899445088:web:d33f39000428c54d212005",
  measurementId: "G-512FV333QR"
};

// ----- imports -----
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
import {
  getFirestore, doc, setDoc, getDoc, collection, addDoc, onSnapshot
} from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

// initialize firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// UI refs
const $ = id => document.getElementById(id);
const createBtn = $('createBtn'), joinBtn = $('joinBtn'), roomIdInput = $('roomId'), roomPassword = $('roomPassword');
const qrWrap = $('qrWrap'), shareLink = $('shareLink'), roomMsg = $('roomMsg');
const muteAudioBtn = $('muteAudio'), muteVideoBtn = $('muteVideo'), exitBtn = $('exitBtn');
const localVideo = $('localVideo'), remoteVideo = $('remoteVideo');
const fileInput = $('fileInput'), fileList = $('fileList'), sendQueueBtn = $('sendQueueBtn'), clearQueueBtn = $('clearQueueBtn');
const sendBar = $('sendBar'), recvBar = $('recvBar'), sendStats = $('sendStats'), recvStats = $('recvStats'), receiveFiles = $('receiveFiles');
const logEl = $('log'), toast = $('toast'), themeToggle = $('themeToggle'), bitrateInput = $('bitrateInput');

// state
let pc = null;
let localStream = null;
let dataChannel = null;
let currentRoomRef = null;
let roomId = null;
let pwHashStored = null;
let sendQueue = []; // {file:File, transcode:boolean}
let sending = false;
const CHUNK = 64 * 1024; // 64KB

// helpers
function log(msg){ const t = new Date().toLocaleTimeString(); logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent; }
function showToast(msg, ms=2500){ toast.textContent = msg; toast.style.display='block'; setTimeout(()=>toast.style.display='none', ms); }
async function sha256hex(str){ const b = new TextEncoder().encode(str); const h = await crypto.subtle.digest('SHA-256', b); return Array.from(new Uint8Array(h)).map(x=>x.toString(16).padStart(2,'0')).join(''); }
function updateShareUI(id){ const link = location.href.split('#')[0] + '#room=' + encodeURIComponent(id); shareLink.textContent = link; shareLink.href = link; const qrUrl = 'https://chart.googleapis.com/chart?cht=qr&chs=200x200&chl=' + encodeURIComponent(link); qrWrap.innerHTML = `<img src="${qrUrl}" width="110" height="110" style="border-radius:6px">`; }

// theme toggle
themeToggle.addEventListener('click', ()=> {
  const b = document.body;
  if (b.classList.contains('light')){ b.classList.remove('light'); b.classList.add('dark'); } else { b.classList.remove('dark'); b.classList.add('light'); }
});

// media
async function ensureLocalStream(){
  if (localStream) return localStream;
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video:{width:1280,height:720,frameRate:24}, audio:true });
    localVideo.srcObject = localStream;
    log('Local stream started');
    return localStream;
  } catch(e){ log('getUserMedia error: '+e); alert('Camera & mic permission required'); throw e; }
}

// peer connection
function createPeerConnection(){
  const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
  pc = new RTCPeerConnection(config);
  if (localStream) for (const t of localStream.getTracks()) pc.addTrack(t, localStream);

  pc.ontrack = ev => { remoteVideo.srcObject = ev.streams[0]; log('Remote stream added'); };

  pc.onicecandidate = e => {
    if (e.candidate && currentRoomRef){
      addDoc(collection(currentRoomRef, 'candidates'), { candidate: JSON.stringify(e.candidate) }).catch(err=>log('ICE push err:'+err));
    }
  };

  pc.onconnectionstatechange = ()=> log('PC state: ' + pc.connectionState);
  return pc;
}

// data channel setup
function setupDataChannel(channel){
  dataChannel = channel;
  dataChannel.binaryType = 'arraybuffer';
  dataChannel.onopen = ()=> { log('DataChannel open'); showToast('DataChannel open'); };
  dataChannel.onclose = ()=> { log('DataChannel closed'); showToast('DataChannel closed'); };

  // receive logic
  let incomingBuffers = [];
  let incomingSize = 0;
  let incomingName = '';
  let receivedBytes = 0;

  dataChannel.onmessage = ev => {
    if (typeof ev.data === 'string'){
      try {
        const control = JSON.parse(ev.data);
        if (control.type === 'meta'){
          incomingName = control.name; incomingSize = control.size; incomingBuffers = []; receivedBytes = 0;
          recvBar.style.width = '0%';
          recvStats.textContent = `Receiving ${incomingName} (${(incomingSize/1024/1024).toFixed(2)} MB)`;
          log('Receiving meta: ' + incomingName);
        } else if (control.type === 'done'){
          const blob = new Blob(incomingBuffers);
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = incomingName; a.textContent = `Download ${incomingName} (${(incomingSize/1024/1024).toFixed(2)} MB)`; a.style.display='block';
          receiveFiles.prepend(a);
          recvStats.textContent = `Received ${incomingName}`;
          recvBar.style.width = '100%';
          log('Receive complete: ' + incomingName);
        }
      } catch(e){ console.warn('bad ctrl', e); }
    } else {
      incomingBuffers.push(ev.data);
      receivedBytes += ev.data.byteLength;
      const pct = incomingSize ? (receivedBytes / incomingSize * 100) : 0;
      recvBar.style.width = pct + '%';
      recvStats.textContent = `${(receivedBytes/1024/1024).toFixed(2)} MB received`;
    }
  };
}

// create room
createBtn.addEventListener('click', async ()=>{
  const id = roomIdInput.value.trim();
  const pw = roomPassword.value || '';
  if (!id) { roomMsg.textContent = 'Enter Room ID'; roomMsg.style.color='orangered'; return; }
  if (!pw) { roomMsg.textContent = 'Password required'; roomMsg.style.color='orangered'; return; }

  createBtn.disabled = true;
  try {
    await ensureLocalStream();
    createPeerConnection();
    const dc = pc.createDataChannel('file'); setupDataChannel(dc);

    const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
    const h = await sha256hex(pw); pwHashStored = h;

    const roomRef = doc(db, 'rooms', id);
    currentRoomRef = roomRef; roomId = id;

    // write room (offer + pwHash)
    await setDoc(roomRef, { offer: JSON.stringify(pc.localDescription), pwHash: h });
    roomMsg.textContent = `Room Created Successfully! Room ID: ${id}`; roomMsg.style.color='limegreen';
    updateShareUI(id); log('Room created: ' + id);

    // listen for answer
    onSnapshot(roomRef, async snap => {
      const data = snap.data();
      if (!data) return;
      if (data.answer && pc && !pc.currentRemoteDescription){
        await pc.setRemoteDescription(JSON.parse(data.answer));
        log('Answer received');
      }
    });

    // listen for candidate docs
    onSnapshot(collection(roomRef, 'candidates'), snap => {
      snap.docChanges().forEach(async change => {
        if (change.type === 'added'){
          const obj = change.doc.data();
          if (obj && obj.candidate){
            try { await pc.addIceCandidate(new RTCIceCandidate(JSON.parse(obj.candidate))); log('Remote ICE added'); }
            catch(e){ console.warn(e); }
          }
        }
      });
    });

  } catch(err){
    log('Create room failed: ' + err);
    roomMsg.textContent = 'Failed to create room: ' + (err.message || err); roomMsg.style.color='orangered';
  } finally { createBtn.disabled = false; }
});

// join room
joinBtn.addEventListener('click', async ()=>{
  const id = roomIdInput.value.trim();
  const pw = roomPassword.value || '';
  if (!id) { roomMsg.textContent='Enter Room ID'; roomMsg.style.color='orangered'; return; }
  if (!pw) { roomMsg.textContent='Password required'; roomMsg.style.color='orangered'; return; }

  joinBtn.disabled = true;
  try {
    await ensureLocalStream();
    const roomRef = doc(db, 'rooms', id);
    const snap = await getDoc(roomRef);
    if (!snap.exists()) { roomMsg.textContent = 'Room not found'; roomMsg.style.color='orangered'; return; }
    const data = snap.data();
    if (!data.pwHash) { roomMsg.textContent='Room has no password'; roomMsg.style.color='orangered'; return; }
    const h = await sha256hex(pw);
    if (h !== data.pwHash) { roomMsg.textContent='Wrong password'; roomMsg.style.color='orangered'; return; }

    currentRoomRef = roomRef; roomId = id; pwHashStored = h;

    createPeerConnection();
    pc.ondatachannel = ev => setupDataChannel(ev.channel);

    await pc.setRemoteDescription(JSON.parse(data.offer));
    const answer = await pc.createAnswer(); await pc.setLocalDescription(answer);

    await setDoc(roomRef, { answer: JSON.stringify(pc.localDescription) }, { merge: true });
    roomMsg.textContent = `Joined Room Successfully: ${id}`; roomMsg.style.color='limegreen';
    updateShareUI(id); log('Joined room & posted answer');

    onSnapshot(collection(roomRef, 'candidates'), snap2 => {
      snap2.docChanges().forEach(async change => {
        if (change.type === 'added'){
          const obj = change.doc.data();
          if (obj && obj.candidate){
            try{ await pc.addIceCandidate(new RTCIceCandidate(JSON.parse(obj.candidate))); log('Remote ICE added'); }
            catch(e){ console.warn(e); }
          }
        }
      });
    });

  } catch(err){
    log('Join failed: ' + err);
    roomMsg.textContent = 'Failed to join: ' + (err.message || err); roomMsg.style.color='orangered';
  } finally { joinBtn.disabled = false; }
});

// mute/unmute & exit
muteAudioBtn.addEventListener('click', ()=>{
  if (!localStream) return alert('No local stream'); const t = localStream.getAudioTracks()[0]; t.enabled = !t.enabled; muteAudioBtn.textContent = t.enabled ? 'Mute Audio' : 'Unmute Audio'; log('Audio '+(t.enabled?'on':'off'));
});
muteVideoBtn.addEventListener('click', ()=>{
  if (!localStream) return alert('No local stream'); const t = localStream.getVideoTracks()[0]; t.enabled = !t.enabled; muteVideoBtn.textContent = t.enabled ? 'Mute Video' : 'Unmute Video'; log('Video '+(t.enabled?'on':'off'));
});
exitBtn.addEventListener('click', ()=>{
  if (pc) pc.close(); pc = null; if (localStream) { localStream.getTracks().forEach(t=>t.stop()); localStream=null; } roomMsg.textContent='Left room'; log('Left room');
});

// file queue UI
fileInput.addEventListener('change', (ev)=>{
  const files = Array.from(ev.target.files || []);
  for (const f of files) sendQueue.push({ file: f, transcode: true });
  renderQueue();
});
function renderQueue(){
  fileList.innerHTML=''; sendQueue.forEach((it,idx)=>{
    const f=it.file;
    const div=document.createElement('div'); div.className='fileRow';
    div.innerHTML = `<div style="flex:1"><strong>${f.name}</strong><br><small class="small">${(f.size/1024/1024).toFixed(2)} MB</small></div>
      <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
        <label class="small">Transcode <input type="checkbox" data-idx="${idx}" class="tc" ${it.transcode?'checked':''}></label>
        <div><button data-idx="${idx}" class="ghost removeBtn">Delete</button></div>
      </div>`;
    fileList.appendChild(div);
  });
  fileList.querySelectorAll('.removeBtn').forEach(b=>b.addEventListener('click', e=>{ const i=parseInt(b.getAttribute('data-idx')); sendQueue.splice(i,1); renderQueue(); }));
  fileList.querySelectorAll('.tc').forEach(cb=>cb.addEventListener('change', e=>{ const i=parseInt(cb.getAttribute('data-idx')); sendQueue[i].transcode = cb.checked; }));
}
clearQueueBtn.addEventListener('click', ()=>{ sendQueue=[]; renderQueue(); });

// ffmpeg.wasm (load on demand)
let ffmpeg = null, ffmpegLoading=false;
async function ensureFFmpeg(){
  if (ffmpeg) return ffmpeg;
  if (ffmpegLoading){ while(!ffmpeg) await new Promise(r=>setTimeout(r,200)); return ffmpeg; }
  ffmpegLoading = true;
  log('Loading ffmpeg.wasm (may take a few seconds)...');
  const { createFFmpeg } = await import('https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.2/dist/ffmpeg.min.js');
  ffmpeg = createFFmpeg({ log:false });
  ffmpeg.setProgress(p => { if (p && p.ratio !== undefined) { const pct=Math.round(p.ratio*100); sendStats.textContent = `Transcoding: ${pct}%`; } });
  await ffmpeg.load();
  log('ffmpeg.wasm loaded');
  return ffmpeg;
}
async function transcodeFileToMp4(file, targetKbps){
  const f = await ensureFFmpeg();
  const inName = 'in.' + (file.name.split('.').pop() || 'mp4');
  const outName = 'out.mp4';
  f.FS('writeFile', inName, await f.fetchFile(file));
  const args = ['-i', inName, '-c:v','libx264','-preset','veryfast','-b:v',`${targetKbps}k`, '-maxrate',`${Math.round(targetKbps*1.2)}k`, '-bufsize',`${Math.round(targetKbps*2)}k`, '-c:a','aac','-b:a','96k','-movflags','+faststart', outName];
  log(`Transcoding to ${targetKbps} kbps...`);
  await f.run(...args);
  const data = f.FS('readFile', outName);
  const blob = new Blob([data.buffer], { type: 'video/mp4' });
  try { f.FS('unlink', inName); f.FS('unlink', outName); } catch(e){}
  log('Transcode done: ' + (blob.size/1024/1024).toFixed(2) + ' MB');
  return blob;
}

// send queue
sendQueueBtn.addEventListener('click', async ()=>{
  if (!dataChannel || dataChannel.readyState !== 'open'){ alert('DataChannel not open yet — wait for connection'); return; }
  if (sendQueue.length===0
