<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>P2P File Transfer — Debuggable</title>
<style>
  body{font-family:Arial,system-ui;margin:0;padding:16px;background:#0b1220;color:#e6eef6}
  .wrap{max-width:1100px;margin:0 auto}
  .card{background:#071022;padding:14px;border-radius:10px;margin-bottom:12px}
  input,button,select{font:inherit;padding:10px;border-radius:8px}
  input{width:100%;box-sizing:border-box;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .col{flex:1;min-width:220px}
  .btn{background:#06b6d4;color:#021018;border:none;padding:10px 12px;border-radius:8px;cursor:pointer}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#9aa9b8}
  .small{font-size:13px;color:#9aa9b8}
  pre{background:#071426;padding:10px;border-radius:8px;height:200px;overflow:auto}
  .success{color:#22c55e}
  .err{color:#fb7185}
  .progress{height:12px;background:rgba(255,255,255,0.03);border-radius:999px;overflow:hidden}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,#34d399,#06b6d4);width:0%}
  .hidden{display:none}
</style>
</head>
<body>
<div class="wrap">
  <h2>P2P File Transfer — Debug Friendly</h2>

  <div class="card">
    <div class="small">Quick check — verify Firestore connectivity</div>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="testFs" class="btn">Test Firestore</button>
      <button id="openConsole" class="ghost">Open Console Tip</button>
    </div>
    <div id="testMsg" style="margin-top:8px"></div>
  </div>

  <div class="card">
    <div class="row">
      <div class="col">
        <label class="small">Room ID</label>
        <input id="roomId" placeholder="room-id (same on both devices)">
      </div>
      <div style="width:220px">
        <label class="small">Password</label>
        <input id="roomPassword" placeholder="required">
      </div>
      <div style="width:200px;display:flex;flex-direction:column;gap:8px">
        <button id="createBtn" class="btn">Create Room</button>
        <button id="joinBtn" class="btn">Join Room</button>
      </div>
      <div style="width:160px;text-align:center">
        <div class="small">Share / QR</div>
        <div id="qr" style="margin-top:6px;background:#071428;border-radius:8px;padding:8px;width:120px;height:120px"></div>
        <a id="shareLink" class="small" href="#" target="_blank" style="display:block;margin-top:6px;color:#06b6d4"></a>
      </div>
    </div>
    <div id="roomMsg" style="margin-top:10px"></div>
  </div>

  <div class="card">
    <div class="row" style="align-items:center">
      <div class="col">
        <div class="small">Local Video</div>
        <video id="localVideo" autoplay playsinline muted style="width:100%;height:220px;background:#000;border-radius:8px"></video>
      </div>
      <div class="col">
        <div class="small">Remote Video</div>
        <video id="remoteVideo" autoplay playsinline style="width:100%;height:220px;background:#000;border-radius:8px"></video>
      </div>
    </div>

    <div style="margin-top:10px;display:flex;gap:8px">
      <button id="muteAudio" class="ghost">Mute Audio</button>
      <button id="muteVideo" class="ghost">Mute Video</button>
      <button id="exitBtn" class="ghost">Exit Room</button>
    </div>
  </div>

  <div class="card">
    <div class="small">Files (queue)</div>
    <input id="fileInput" type="file" multiple style="margin-top:8px">
    <div id="fileList" style="margin-top:8px"></div>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="sendBtn" class="btn">Send Queue</button>
      <button id="clearBtn" class="ghost">Clear Queue</button>
    </div>

    <div style="margin-top:12px">
      <div class="small">Send Progress</div>
      <div class="progress" style="margin-top:6px"><i id="sendBar" style="width:0%"></i></div>
      <div id="sendTxt" class="small" style="margin-top:6px"></div>
    </div>

    <div style="margin-top:12px">
      <div class="small">Receive Progress</div>
      <div class="progress" style="margin-top:6px"><i id="recvBar" style="width:0%"></i></div>
      <div id="recvTxt" class="small" style="margin-top:6px"></div>
      <div id="downloads" style="margin-top:8px"></div>
    </div>
  </div>

  <div class="card">
    <div class="small">Logs</div>
    <pre id="log"></pre>
  </div>
</div>

<script type="module">
/* ===========================
   Debug-friendly single file
   Firestore v10 modular, explicit errors & messages
   =========================== */

/* ---------- Firebase v10 config (your config) ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyB0Ex5-_mLf8KNENaK0ugRk7ow1fORUq2k",
  authDomain: "sending-file-90a27.firebaseapp.com",
  projectId: "sending-file-90a27",
  storageBucket: "sending-file-90a27.firebasestorage.app",
  messagingSenderId: "319899445088",
  appId: "1:319899445088:web:d33f39000428d212005", // NOTE: keep your actual appId (I use yours earlier)
  measurementId: "G-512FV333QR"
};

/* ---------- imports ---------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
import {
  getFirestore, doc, setDoc, getDoc, collection, addDoc, onSnapshot
} from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

/* ---------- initialize ---------- */
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ---------- DOM refs ---------- */
const $ = id => document.getElementById(id);
const testFs = $('testFs'), openConsole = $('openConsole');
const createBtn = $('createBtn'), joinBtn = $('joinBtn'), roomIdInput = $('roomId'), roomPassword = $('roomPassword');
const roomMsg = $('roomMsg'), qr = $('qr'), shareLink = $('shareLink');
const localVideo = $('localVideo'), remoteVideo = $('remoteVideo');
const muteAudio = $('muteAudio'), muteVideo = $('muteVideo'), exitBtn = $('exitBtn');
const fileInput = $('fileInput'), fileList = $('fileList'), sendBtn = $('sendBtn'), clearBtn = $('clearBtn');
const sendBar = $('sendBar'), recvBar = $('recvBar'), sendTxt = $('sendTxt'), recvTxt = $('recvTxt'), downloads = $('downloads');
const logEl = $('log'), testMsg = $('testMsg');

/* ---------- small UI helpers ---------- */
function log(msg){ const t = new Date().toLocaleTimeString(); logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent; }
function setRoomMessage(text, ok=true){ roomMsg.innerHTML = text; roomMsg.className = ok ? 'success' : 'err'; }
function updateQRAndLink(id){ const link = location.href.split('#')[0] + '#room=' + encodeURIComponent(id); shareLink.href = link; shareLink.textContent = link; qr.innerHTML = `<img src="https://chart.googleapis.com/chart?cht=qr&chs=200x200&chl=${encodeURIComponent(link)}" width="110" height="110"/>`; }

/* ---------- Firestore test (explicit error display) ---------- */
testFs.addEventListener('click', async () => {
  testFs.disabled = true;
  testMsg.textContent = 'Testing Firestore...';
  try {
    // write a tiny doc and read it
    const testRef = doc(db, 'test_connection', 'ping');
    await setDoc(testRef, { ts: Date.now() });
    const snap = await getDoc(testRef);
    if (snap.exists()) {
      testMsg.innerHTML = '<span style="color:limegreen">Firestore write/read OK</span>';
      log('Firestore test OK');
    } else {
      testMsg.innerHTML = '<span style="color:orangered">Firestore read failed (no doc)</span>';
      log('Firestore test: doc missing after write');
    }
  } catch(e) {
    // show full error message so user can copy it
    testMsg.innerHTML = `<span style="color:orangered">Firestore error: ${e && e.message ? e.message : e}</span>`;
    log('Firestore test error: ' + (e && e.message ? e.message : e));
  } finally {
    testFs.disabled = false;
  }
});

/* ---------- basic WebRTC + Firestore signaling (simplified) ---------- */
let pc = null, dataChannel = null, localStream = null, roomRefGlobal = null;
let sendQueue = []; // array of File
const CHUNK = 64 * 1024;

/* get media */
async function startLocal() {
  if (localStream) return localStream;
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
    localVideo.srcObject = localStream;
    log('Local stream started');
    return localStream;
  } catch(e) {
    log('getUserMedia error: ' + e);
    alert('Allow camera & mic');
    throw e;
  }
}

/* create peer */
function createPC() {
  pc = new RTCPeerConnection({ iceServers:[{urls:'stun:stun.l.google.com:19302'}] });
  if (localStream) for (const t of localStream.getTracks()) pc.addTrack(t, localStream);
  pc.ontrack = e => {
    remoteVideo.srcObject = e.streams[0];
    log('Remote stream received');
  };
  pc.onicecandidate = e => {
    if (e.candidate && roomRefGlobal) {
      // push candidate to subcollection
      addDoc(collection(roomRefGlobal, 'candidates'), { candidate: JSON.stringify(e.candidate) })
        .catch(err => log('addDoc ICE error: ' + err));
    }
  };
  pc.onconnectionstatechange = () => log('PC state: ' + pc.connectionState);
  return pc;
}

/* data channel handlers */
function attachDataChannel(dc) {
  dataChannel = dc;
  dataChannel.binaryType = 'arraybuffer';
  dataChannel.onopen = () => log('DataChannel open');
  dataChannel.onclose = () => log('DataChannel closed');
  dataChannel.onmessage = ev => {
    if (typeof ev.data === 'string') {
      try {
        const ctl = JSON.parse(ev.data);
        if (ctl.type === 'meta') {
          recvTxt.textContent = `Receiving ${ctl.name} (${(ctl.size/1024/1024).toFixed(2)} MB)`;
          downloads.innerHTML = '';
          recvBar.style.width = '0%';
        } else if (ctl.type === 'done') {
          log('Receiver: done control message');
        }
      } catch(e){ console.warn('ctrl parse err', e); }
    } else {
      // raw chunk receive: accumulate into a blob per transfer - for demo we simply create a downloadable blob directly
      // Note: a production app should assemble chunks into buffers and provide a proper progress bar
      const blob = new Blob([ev.data]);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'received_file'; a.textContent = 'Download received file'; a.style.display='block';
      downloads.prepend(a);
      recvBar.style.width = '100%';
      recvTxt.textContent = 'Received chunk (saved as file)';
    }
  };
}

/* Create Room */
createBtn.addEventListener('click', async () => {
  const id = roomIdInput.value.trim();
  const pw = roomPassword.value || '';
  if (!id) { setRoomMessage('Enter Room ID', false); return; }
  if (!pw) { setRoomMessage('Password required', false); return; }

  createBtn.disabled = true;
  setRoomMessage('Creating room...', true);
  try {
    await startLocal();
    createPC();
    // caller creates dataChannel
    const dc = pc.createDataChannel('file');
    attachDataChannel(dc);

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    // store in Firestore (offer + pwHash)
    const h = await sha256hex(pw);
    const roomRef = doc(db, 'rooms', id);
    roomRefGlobal = roomRef;
    try {
      await setDoc(roomRef, { offer: JSON.stringify(pc.localDescription), pwHash: h });
    } catch(e) {
      // show clear error and return early
      setRoomMessage('Failed to write room to Firestore: ' + (e.message || e), false);
      log('setDoc error: ' + (e.message || e));
      createBtn.disabled = false;
      return;
    }

    setRoomMessage('Room Created Successfully! Room ID: ' + id, true);
    updateQRAndLink(id);
    log('Room created and offer saved: ' + id);

    // listen for answer updates
    onSnapshot(roomRef, async snap => {
      const data = snap.data();
      if (!data) return;
      if (data.answer && pc && !pc.currentRemoteDescription) {
        try {
          await pc.setRemoteDescription(JSON.parse(data.answer));
          log('Answer set as remote description');
        } catch(e) { log('setRemoteDescription error: ' + e); }
      }
    });

    // listen for ICE candidates from remote
    onSnapshot(collection(roomRef, 'candidates'), snap => {
      snap.docChanges().forEach(async change => {
        if (change.type === 'added') {
          const obj = change.doc.data();
          if (obj && obj.candidate) {
            try {
              await pc.addIceCandidate(new RTCIceCandidate(JSON.parse(obj.candidate)));
              log('Remote ICE candidate added');
            } catch(e) { log('addIceCandidate error: ' + e); }
          }
        }
      });
    });

  } catch(e) {
    log('Create room error: ' + e);
    setRoomMessage('Create room failed: ' + (e.message || e), false);
  } finally { createBtn.disabled = false; }
});

/* Join Room */
joinBtn.addEventListener('click', async () => {
  const id = roomIdInput.value.trim();
  const pw = roomPassword.value || '';
  if (!id) { setRoomMessage('Enter Room ID', false); return; }
  if (!pw) { setRoomMessage('Password required', false); return; }

  joinBtn.disabled = true;
  setRoomMessage('Joining room...', true);
  try {
    await startLocal();
    const roomRef = doc(db, 'rooms', id);
    roomRefGlobal = roomRef;

    // fetch room doc
    let snap;
    try {
      snap = await getDoc(roomRef);
    } catch(e) {
      setRoomMessage('Failed to read room from Firestore: ' + (e.message || e), false);
      log('getDoc error: ' + (e.message || e));
      joinBtn.disabled = false;
      return;
    }

    if (!snap.exists()) {
      setRoomMessage('Room not found', false);
      joinBtn.disabled = false;
      return;
    }
    const data = snap.data();
    if (!data.pwHash) { setRoomMessage('Room has no password', false); joinBtn.disabled=false; return; }
    const h = await sha256hex(pw);
    if (h !== data.pwHash) { setRoomMessage('Wrong password', false); joinBtn.disabled=false; return; }

    // set up PC & set remote offer
    createPC();
    pc.ondatachannel = ev => attachDataChannel(ev.channel);

    try {
      await pc.setRemoteDescription(JSON.parse(data.offer));
    } catch(e) { setRoomMessage('setRemoteDescription failed: ' + (e.message || e), false); log('setRemoteDescription error: ' + e); joinBtn.disabled=false; return; }

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    // write answer back to Firestore (merge)
    try {
      await setDoc(roomRef, { answer: JSON.stringify(pc.localDescription) }, { merge: true });
    } catch(e) {
      setRoomMessage('Failed to write answer to Firestore: ' + (e.message || e), false);
      log('setDoc answer error: ' + e);
      joinBtn.disabled = false;
      return;
    }

    setRoomMessage('Joined Room Successfully: ' + id, true);
    updateQRAndLink(id);
    log('Joined room and posted answer');

    // listen for ICE candidates from caller
    onSnapshot(collection(roomRef, 'candidates'), snap2 => {
      snap2.docChanges().forEach(async change => {
        if (change.type === 'added') {
          const obj = change.doc.data();
          if (obj && obj.candidate) {
            try {
              await pc.addIceCandidate(new RTCIceCandidate(JSON.parse(obj.candidate)));
              log('Remote ICE candidate added');
            } catch(e) {
              log('addIceCandidate error: ' + e);
            }
          }
        }
      });
    });

  } catch(e) {
    log('Join error: ' + e);
    setRoomMessage('Join failed: ' + (e.message || e), false);
  } finally { joinBtn.disabled = false; }
});

/* ---------- small utilities for files (queue & send) ---------- */
fileInput.addEventListener('change', (ev) => {
  const files = Array.from(ev.target.files || []);
  sendQueue.push(...files);
  renderFileList();
});
function renderFileList(){
  fileList.innerHTML = '';
  sendQueue.forEach((f, i) => {
    const div = document.createElement('div'); div.style.display='flex'; div.style.justifyContent='space-between'; div.style.alignItems='center'; div.style.marginTop='8px';
    div.innerHTML = `<div><strong>${f.name}</strong><div class="small">${(f.size/1024/1024).toFixed(2)} MB</div></div><div><button data-i="${i}" class="ghost remove">Delete</button></div>`;
    fileList.appendChild(div);
  });
  fileList.querySelectorAll('.remove').forEach(b => b.addEventListener('click', e => { const i=parseInt(b.getAttribute('data-i')); sendQueue.splice(i,1); renderFileList(); }));
}
clearBtn.addEventListener('click', ()=>{ sendQueue=[]; renderFileList(); });

/* Very simple send: sends raw files (no transcode) in chunks */
sendBtn.addEventListener('click', async () => {
  if (!dataChannel || dataChannel.readyState !== 'open') { alert('DataChannel not open yet'); return; }
  if (sendQueue.length === 0) return alert('No files selected');
  sendBtn.disabled = true;
  let total = sendQueue.reduce((s,f)=>s+f.size,0), sent=0;
  try {
    for (const f of sendQueue) {
      // send meta
      dataChannel.send(JSON.stringify({ type:'meta', name: f.name, size: f.size }));
      log('Sending: ' + f.name);
      const reader = f.stream().getReader();
      while(true){
        const {done, value} = await reader.read();
        if (done) break;
        // chunking inside value may be large; we send in slices
        let offset = 0;
        while (offset < value.byteLength) {
          const end = Math.min(offset + CHUNK, value.byteLength);
          const slice = value.subarray(offset, end);
          // flow control
          while (dataChannel.bufferedAmount > CHUNK * 16) await new Promise(r=>setTimeout(r,50));
          dataChannel.send(slice);
          sent += slice.byteLength;
          sendBar.style.width = ((sent/total)*100) + '%';
          sendTxt.textContent = `${(sent/1024/1024).toFixed(2)} MB / ${(total/1024/1024).toFixed(2)} MB`;
          offset = end;
        }
      }
      dataChannel.send(JSON.stringify({ type:'done' }));
      log('Finished sending: ' + f.name);
    }
    showToast('All files sent', 3000);
  } catch(e) {
    log('Send failed: ' + e);
    alert('Send failed: ' + e);
  } finally {
    sendBtn.disabled = false;
  }
});

/* mute/video/exit handlers */
muteAudio.addEventListener('click', ()=> {
  if (!localStream) return alert('No local stream'); const t = localStream.getAudioTracks()[0]; t.enabled = !t.enabled; muteAudio.textContent = t.enabled ? 'Mute Audio' : 'Unmute Audio';
});
muteVideo.addEventListener('click', ()=> {
  if (!localStream) return alert('No local stream'); const t = localStream.getVideoTracks()[0]; t.enabled = !t.enabled; muteVideo.textContent = t.enabled ? 'Mute Video' : 'Unmute Video';
});
exitBtn.addEventListener('click', ()=> {
  if (pc) pc.close(); pc = null;
  if (localStream) { localStream.getTracks().forEach(t=>t.stop()); localStream = null; }
  setRoomMessage('Left room', true);
  log('Exited room & stopped local stream');
});

/* tiny helper: hash password (sha256 hex) */
async function sha256hex(str){
  const enc = new TextEncoder().encode(str);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
}

/* convenience: open console instructions */
openConsole.addEventListener('click', ()=> {
  alert('On Android Chrome: Menu → More tools → Developer tools via remote debugging (chrome://inspect) or open on desktop and press F12 to see Console logs.');
});

/* attempt to pre-fill room id from URL fragment */
(function loadRoomFromHash(){
  const m = location.hash.match(/room=([^&]+)/);
  if (m) roomIdInput.value = decodeURIComponent(m[1]);
})();

log('App initialized. Click "Test Firestore" to verify connectivity and rules.');
</script>
</body>
</html>
